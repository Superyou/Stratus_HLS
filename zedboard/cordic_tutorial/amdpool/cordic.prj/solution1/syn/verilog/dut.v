// Generated by stratus_vlg 15.21-p100  (11111646)
// Mon Aug 29 17:37:36 2016
// from bdw_work/wrappers/simple_FIFO_wrap.cc

`timescale 1ns / 1ps

      
// Generated by stratus_hls 15.21-p100  (11111647)
// Mon Aug 29 17:37:27 2016
// from simple_FIFO.cc
/* Include declarations of instantiated parts. */
/* Declaration of the synthesized module. */
module dut(clk, rst, din_data, din_empty, din_read, dout_data, dout_full, dout_write);

      input clk;
      input rst;
      input [31:0] din_data;
      input din_empty;
      input dout_full;
      output din_read;
      reg din_read;
      output [31:0] dout_data;
      reg [31:0] dout_data;
      output dout_write;
      reg dout_write;
      wire[31:0] simple_FIFO_Add_32U_1_4_1_out1;
      wire[31:0] simple_FIFO_Add2i1u32_4_2_out1;
      reg[3:0] global_state_next;
      reg[31:0] s_reg_3;
      reg[31:0] s_reg_4;
      reg[3:0] global_state;

         // Generated by stratus_hls 15.21-p100  (11111647)
         // Mon Aug 29 17:37:27 2016
         // from simple_FIFO.cc
         // resource: mux_1bx2i
         // resource: regr_1b
         always @(posedge clk)
          begin :drive_dout_write
            if (rst == 1'b1) begin
               dout_write <= 1'd0;
            end
            else begin
               case (global_state) 

                  4'd06, 4'd07, 4'd09, 4'd10: begin
                     if (dout_full) begin
                        dout_write <= 1'd0;
                     end
                     else begin
                        dout_write <= 1'd1;
                     end
                  end
                  
                  4'd08, 4'd11: begin
                     dout_write <= 1'd0;
                  end
                  
               endcase

            end
         end

         // resource: mux_32bx2i
         // resource: regr_32b
         always @(posedge clk)
          begin :drive_dout_data
            case (global_state) 

               4'd06, 4'd07: begin
                  if (dout_full) begin
                  end
                  else begin
                     dout_data <= s_reg_4;
                  end
               end
               
               4'd09, 4'd10: begin
                  if (dout_full) begin
                  end
                  else begin
                     dout_data <= simple_FIFO_Add2i1u32_4_2_out1;
                  end
               end
               
            endcase

         end

         // resource: mux_1bx2i
         // resource: regr_1b
         always @(posedge clk)
          begin :drive_din_read
            if (rst == 1'b1) begin
               din_read <= 1'd0;
            end
            else begin
               case (global_state) 

                  4'd00, 4'd01, 4'd03, 4'd04, 4'd12: begin
                     if (din_empty) begin
                        din_read <= 1'd0;
                     end
                     else begin
                        din_read <= 1'd1;
                     end
                  end
                  
                  4'd02, 4'd05: begin
                     din_read <= 1'd0;
                  end
                  
               endcase

            end
         end

         // resource: regr_32b
         always @(posedge clk)
          begin :drive_s_reg_3
            case (global_state) 

               4'd00, 4'd01, 4'd12: begin
                  s_reg_3 <= din_data;
               end
               
            endcase

         end

         // resource: regr_32b
         always @(posedge clk)
          begin :drive_s_reg_4
            case (global_state) 

               4'd03, 4'd04: begin
                  s_reg_4 <= simple_FIFO_Add_32U_1_4_1_out1;
               end
               
            endcase

         end

         // resource: simple_FIFO_Add_32U_1_4  instance: simple_FIFO_Add_32U_1_4_1
         assign simple_FIFO_Add_32U_1_4_1_out1 = s_reg_3 + din_data;

         // resource: simple_FIFO_Add2i1u32_4  instance: simple_FIFO_Add2i1u32_4_2
         assign simple_FIFO_Add2i1u32_4_2_out1 = s_reg_4 + 32'd0000000001;

         // resource: regr_4b
         always @(posedge clk)
          begin :drive_global_state
            if (rst == 1'b1) begin
               global_state <= 4'd00;
            end
            else begin
               global_state <= global_state_next;
            end
         end

         // resource: mux_4bx9i
         always @(global_state or din_empty or dout_full)
          begin :drive_global_state_next
            case (global_state) 

               4'd00, 4'd01, 4'd12: begin
                  if (din_empty) begin
                     global_state_next = 4'd01;
                  end
                  else begin
                     global_state_next = 4'd02;
                  end
               end
               
               4'd03, 4'd04: begin
                  if (din_empty) begin
                     global_state_next = 4'd04;
                  end
                  else begin
                     global_state_next = 4'd05;
                  end
               end
               
               4'd06, 4'd07: begin
                  if (dout_full) begin
                     global_state_next = 4'd07;
                  end
                  else begin
                     global_state_next = 4'd08;
                  end
               end
               
               4'd09, 4'd10: begin
                  if (dout_full) begin
                     global_state_next = 4'd10;
                  end
                  else begin
                     global_state_next = 4'd11;
                  end
               end
               
               default: begin
                  global_state_next = global_state + 4'd01;
               end
               
            endcase

         end


endmodule

