
/**************************************************************************
**
** This file is part of the Stratus ™ software product and is protected 
** by law including United States copyright laws, international treaty 
** provisions, and other applicable laws.
**
** Copyright © 2015 Cadence Design Systems and / or its subsidiary(-ies).  All
** rights reserved.
**
** This file may only be used under the terms of an active Stratus Software 
** License Agreement (SLA) and only for the limited “Purpose” stated in that
** agreement. All clauses in the SLA apply to the contents of this file,
** including, but not limited to, Confidentiality, License rights, Warranty
** and Limitation of Liability.
**
** If you have any questions regarding the use of this file, please contact
** Cadence Design Systems.
**
***************************************************************************/

// Generated by bdw_memgen 15.21-p100
// Fri Jul 22 15:55:19 EDT 2016

#if defined STRATUS  &&  ! defined CYN_DONT_SUPPRESS_MSGS
#pragma cyn_suppress_msgs NOTE
#endif	// STRATUS  &&  CYN_DONT_SUPPRESS_MSGS
#include "MY_RAM.h"
 
#ifdef STRATUS_HLS
   sc_uint<16> MY_RAM::read0(sc_uint<10> A0, bool WE0) {
      sc_uint<16> DOUT0;
      CYN_BIND(WE0,this->WE0);
      CYN_BIND(A0,this->A0);
      CYN_BIND(DOUT0,this->DOUT0);
      DOUT0 = mem[A0];
      return DOUT0;
   }

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   sc_uint<16> MY_RAM::write0(sc_uint<10> A0, sc_uint<16> DIN0, bool WE0) {

      CYN_BIND(WE0,this->WE0);
      CYN_BIND(A0,this->A0);
      CYN_BIND(DIN0,this->DIN0);
      mem[A0] = DIN0;
      return DIN0;
   }

#endif	// STRATUS_HLS
   void MY_RAM::nop0(bool WE0) {
      CYN_BIND(WE0,this->WE0);
   }

   void MY_RAM::thread0() {
#if defined(__GNUC__) && BDW_USE_SCV
    if ( m_p1_tx_0.is_active() ) {
        m_p1_tx_stream->end_tx( m_p1_tx_0, DOUT0.read() );
    }
#endif
#if defined(__GNUC__)
      // Perform an address range check to prevent crashes on out of bounds
      // accesses in SystemC behavioral simulations.
      if((int)(A0.read()) <= 1023) {
#endif
        if(WE0.read() == 0) {

#if defined(__GNUC__) && BDW_USE_SCV
            m_p1_tx_0 = m_p1_tx_stream->begin_write_tx( A0.read(), DIN0.read() );
#endif

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s: %s: write 0x%s to 0x%x\n", name(), sc_time_stamp().to_string().c_str(), DIN0.read().to_string(SC_HEX).c_str(), (int)A0.read().to_uint());
#endif
        mem[A0.read().to_uint()] = DIN0.read();
        } else {

#if defined(__GNUC__) && BDW_USE_SCV
            m_p1_tx_0 = m_p1_tx_stream->begin_read_tx( A0.read() );
#endif

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s: %s: read 0x%s from 0x%x\n", name(), sc_time_stamp().to_string().c_str(), mem[A0.read().to_uint()].to_string(SC_HEX).c_str(), (int)A0.read().to_uint());
#endif
        DOUT0 = mem[A0.read().to_uint()];
        }

#if defined(__GNUC__)
      }
#endif
  }
#if defined(STRATUS_VLG)
   MY_RAM::MY_RAM(const sc_module_name name)
      : sc_module( name ) ,CLK("CLK"),WE0("WE0"),DIN0("DIN0"),DOUT0("DOUT0"),A0("A0"), mem()
#else
   MY_RAM::MY_RAM( sc_module_name name)
      : sc_module( name ) ,CLK("CLK"),WE0("WE0"),DIN0("DIN0"),DOUT0("DOUT0"),A0("A0"), mem() 
#endif
   {
#ifdef STRATUS_HLS
      SC_CTHREAD( thread0, (CLK).pos() );
#else
      SC_METHOD( thread0 );
      sensitive << (CLK).pos();

#endif
#ifndef STRATUS_HLS
      dont_initialize();
#endif
#if defined(__GNUC__) && BDW_USE_SCV
    esc_enable_scv_logging();
    m_p1_tx_stream = new cynw_scv_memory_tx_stream< sc_uint<10>, sc_uint<16> >( (std::string("sc_main.") + std::string(this->name())).c_str(), esc_get_scv_tr_db() );
#endif
 
   }

const unsigned long MY_RAM::implemented = 1;
const unsigned long MY_RAM::pipelined = 1;
const float MY_RAM::area = 0.0000;
const float MY_RAM::delay = 0.0100;
const float MY_RAM::setup_time = 0.0100;
const unsigned long MY_RAM::latency_WE0 = 1;
const unsigned long MY_RAM::latency_DIN0 = 1;
const unsigned long MY_RAM::latency_A0 = 1;
const unsigned long MY_RAM::bits_per_maskbit_WM0 = 0;
const unsigned long MY_RAM::reg_mem_inputs = 0;
const unsigned long MY_RAM::reg_mem_outputs = 0;
const unsigned long MY_RAM::regs_at_mem_inputs = 0;
const unsigned long MY_RAM::regs_at_mem_outputs = 0;
const unsigned long MY_RAM::no_spec_reads = 1;
const unsigned long MY_RAM::is_mem = 1;
const unsigned long MY_RAM::clock_multiplier = 0;
const bool MY_RAM::has_extra_ports = false;
 
